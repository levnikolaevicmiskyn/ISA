\chapter{Universal Verification Methodology}
\section{Introduction}
The UVM is an open source verification standard consisting in a set of classes that extend the SystemVerilog language with advanced verification capabilities. A UVM testbench is made up of reusable components that are often an extension of the base classes already available and fit into a standardized testbench architecture. The object-oriented approach brings the verification task at an higher level of abstraction, which makes UVM a flexible and efficient environment. 

The general organization separates the verification domain from the DUT and its interface. Only the interface that closely interacts with the DUT needs to specify communication at the signal-level, while the remaining part that carries out most of the verification can operate at the transaction level (Transaction Level Model). 

\paragraph{TLM} Transactions are objects that model all the abstract features of communication between two objects. Interfaces for transaction-level communication are used in UVM to isolate the internal implementation of each component so that different components with the same interface can be swapped easily.
The elementary chunk of data exchanged in a transaction is an object of a custom class derived from \texttt{uvm\_sequence\_item}. This object includes all the variables, constraints and methods required to fully specify how data is structured and delivered in a given transaction. 

Instances of such sequence items exist in the testbench under analysis in two classes: \texttt{packet\_in} and \texttt{packet\_out}. They model the data generated by the sequencer and the packets collected at the DUT's output for checking/scoreboarding. In particular, \texttt{packet\_in} will deserve more attention since it describes the input sequence item as a couple of random integers $A$ and $B$ along with constraints that represent the properties that a valid input sequence must have.

Exchange of data happens, at the most simple level, between a producer component that \textit{puts} data on a port and a consumer with an associated export that \textit{gets} the transaction. The producer is the one that generates a transaction and sends it to its port using the \texttt{put} method. On the other hand, the consumer is expected to give an implementation of the \texttt{put} method, which is called whenever the producer wants to put data to its consumer. 

The converse operation on the consumer's side is to ask for a transaction from the producer. This is accomplished with the \texttt{get} method, called by the consumer and implemented in the producer.
For example, the \texttt{refmod} component contains both a get port and a put port objects, which allows to receive transactions from the agent and to send the result to the scoreboard.

\begin{lstlisting}[language = verilog, caption = Snippet from \textit{refmod.sv}]
packet_in tr_in;
packet_out tr_out;
uvm_get_port #(packet_in) in;
uvm_put_port #(packet_out) out;

virtual task run_phase(uvm_phase phase);
	[...]
	forever begin
		in.get(tr_in); // Get transaction from agent
		[...]
		out.put(tr_out); // Put transaction to the scoreboard
	end
endtask: run_phase
\end{lstlisting}

In this case the transactions are \textit{non-blocking}, they return instantaneously in the same delta cycle in which they are invoked.